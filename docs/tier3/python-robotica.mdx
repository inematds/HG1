---
sidebar_position: 2
title: 2. Python para Rob√≥tica
description: NumPy, OOP, async e boas pr√°ticas
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# üêç Python para Rob√≥tica

:::tip Objetivo do M√≥dulo
Dominar Python avan√ßado para programa√ß√£o de rob√¥s: NumPy, classes, async/await e padr√µes de projeto.
:::

---

## üî¢ NumPy para C√°lculos Vetoriais

### Por Que NumPy?

Rob√¥s trabalham com **vetores** e **matrizes**:
- Posi√ß√£o: `[x, y, z]`
- Rota√ß√£o: matriz 3x3
- Juntas: array de 12-20 √¢ngulos

```python
import numpy as np

# Posi√ß√£o do rob√¥
position = np.array([1.5, 0.3, 0.0])  # x, y, z

# Velocidade
velocity = np.array([0.5, 0.0, 0.0])  # andando para frente

# Nova posi√ß√£o ap√≥s 1 segundo
new_position = position + velocity * 1.0
# array([2.0, 0.3, 0.0])
```

### Opera√ß√µes Essenciais

```python
# Produto escalar (dot product)
v1 = np.array([1, 0, 0])
v2 = np.array([0, 1, 0])
dot = np.dot(v1, v2)  # 0 (perpendiculares)

# Norma (magnitude)
velocity = np.array([3, 4, 0])
speed = np.linalg.norm(velocity)  # 5.0 m/s

# Matriz de rota√ß√£o (2D)
theta = np.pi / 4  # 45 graus
R = np.array([
    [np.cos(theta), -np.sin(theta)],
    [np.sin(theta),  np.cos(theta)]
])

# Rotacionar vetor
v = np.array([1, 0])
v_rotated = R @ v  # @ √© multiplica√ß√£o de matriz
```

---

## üèóÔ∏è Programa√ß√£o Orientada a Objetos

### Classe de Rob√¥

```python
from dataclasses import dataclass
import numpy as np

@dataclass
class RobotState:
    """Estado completo do rob√¥"""
    position: np.ndarray  # [x, y, z]
    orientation: np.ndarray  # quaternion [x, y, z, w]
    joint_angles: np.ndarray  # √¢ngulos de todas as juntas
    battery_level: float  # 0-100%

class HumanoidRobot:
    def __init__(self, name: str):
        self.name = name
        self.state = RobotState(
            position=np.zeros(3),
            orientation=np.array([0, 0, 0, 1]),
            joint_angles=np.zeros(12),
            battery_level=100.0
        )
    
    def walk_forward(self, distance: float):
        """Andar para frente"""
        self.state.position[0] += distance
        self.state.battery_level -= distance * 0.1  # Gasta bateria
    
    def get_status(self) -> dict:
        return {
            'name': self.name,
            'position': self.state.position.tolist(),
            'battery': f'{self.state.battery_level:.1f}%'
        }

# Uso
robot = HumanoidRobot("Atlas-01")
robot.walk_forward(5.0)
print(robot.get_status())
# {'name': 'Atlas-01', 'position': [5.0, 0.0, 0.0], 'battery': '99.5%'}
```

---

## ‚ö° Async/Await para Concorr√™ncia

### Por Que Async?

Rob√¥s fazem **m√∫ltiplas tarefas simult√¢neas**:
- Caminhar
- Processar c√¢mera
- Monitorar sensores
- Responder comandos

```python
import asyncio

async def camera_processor():
    """Processa c√¢mera a 30 FPS"""
    while True:
        # Processar frame
        await asyncio.sleep(1/30)  # 33ms
        print("Frame processado")

async def walk_controller():
    """Controla marcha a 100 Hz"""
    while True:
        # Atualizar controle de pernas
        await asyncio.sleep(1/100)  # 10ms
        print("Step atualizado")

async def main():
    # Executar ambos em paralelo
    await asyncio.gather(
        camera_processor(),
        walk_controller()
    )

# asyncio.run(main())
```

---

## üîó Pr√≥ximos Passos

:::tip Pr√≥ximo M√≥dulo
**[ü§ñ ROS2 Fundamentos ‚Üí](./ros2-fundamentos)**

Nodes, topics, services e comunica√ß√£o entre processos.
:::
