---
sidebar_position: 1
title: 1. IntroduÃ§Ã£o ao SDK do G1
description: Arquitetura, APIs e primeiros passos com o Unitree G1
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# ğŸ¤– IntroduÃ§Ã£o ao SDK do Unitree G1

:::tip Objetivo do MÃ³dulo
Compreender a arquitetura de software do Unitree G1, configurar o ambiente de desenvolvimento, dominar as APIs disponÃ­veis (Python e C++), e criar seu primeiro programa de controle do robÃ´.
:::

---

## ğŸ¯ VisÃ£o Geral do Unitree G1

### EspecificaÃ§Ãµes TÃ©cnicas Completas

| Categoria | EspecificaÃ§Ã£o | Detalhes |
|-----------|---------------|----------|
| **DimensÃµes** | Altura: 1.32m | AjustÃ¡vel via postura (1.15m - 1.45m) |
| | Peso: 55kg | DistribuiÃ§Ã£o: 35kg pernas, 20kg torso+braÃ§os |
| | Largura ombros: 48cm | Permite passagem em portas padrÃ£o |
| **DOF (Graus de Liberdade)** | Standard: 23 DOF | 12 pernas + 7 braÃ§os + 4 torso |
| | Dexterous Hands: +20 DOF | 10 DOF por mÃ£o (dedos articulados) |
| | Total mÃ¡ximo: 43 DOF | ConfiguraÃ§Ã£o completa |
| **ComputaÃ§Ã£o Onboard** | Jetson Orin NX 16GB | 100 TOPS AI performance |
| | CPU: 8-core ARM | Cortex-A78AE @ 2.0GHz |
| | GPU: Ampere (1024 CUDA cores) | FP16 tensor cores |
| | Storage: 256GB NVMe SSD | ExpansÃ­vel via USB 3.2 |
| **Sensores** | Intel RealSense D435i (x2) | Stereo depth + RGB + IMU |
| | IMU 6-axis (torso) | 1000 Hz sampling rate |
| | Force/Torque (pÃ©s) | 4-axis, Â±500N range |
| | Joint encoders (todos) | Magnetic, 14-bit resolution |
| **Atuadores** | Unitree brushless motors | Torque mÃ¡ximo: 45 Nm (quadril) |
| | Reduction ratio: 6:1 - 9:1 | Depende da junta |
| | Peak power: 3.5 kW total | Continuous: 1.2 kW |
| **Bateria** | Capacity: 15000 mAh | Voltage: 48V (4S LiPo) |
| | Runtime: ~2 horas | Carga completa: 1.5h |
| | Hot-swap: Sim | Troca sem desligar |
| **Conectividade** | WiFi 6 (802.11ax) | 2.4GHz + 5GHz dual-band |
| | Ethernet: Gigabit (RJ45) | Porta na parte traseira |
| | Bluetooth 5.2 | Para perifÃ©ricos |
| **Sistema Operacional** | Ubuntu 22.04 LTS | Kernel 5.15 RT-PREEMPT |
| | ROS2 Humble | PrÃ©-instalado e configurado |

### ConfiguraÃ§Ãµes DisponÃ­veis

<Tabs>
<TabItem value="standard" label="ğŸ¦¾ Standard (23 DOF)">

**ComposiÃ§Ã£o:**
- 12 DOF pernas (6 por perna)
  - 3 DOF quadril (pitch, roll, yaw)
  - 1 DOF joelho
  - 2 DOF tornozelo (pitch, roll)
- 7 DOF braÃ§os (3.5 por braÃ§o)
  - 2 DOF ombro (pitch, roll)
  - 1 DOF cotovelo
  - 1 DOF pulso (gripper simples)
- 4 DOF torso
  - 2 DOF cintura (pitch, yaw)
  - 2 DOF pescoÃ§o (pitch, yaw)

**Custo:** Base (~$16,000 USD)
**Uso:** Pesquisa, locomoÃ§Ã£o, manipulaÃ§Ã£o bÃ¡sica

</TabItem>
<TabItem value="dexterous" label="âœ‹ Dexterous Hands (+20 DOF)">

**Adicionais:**
- 10 DOF por mÃ£o (20 total)
  - Polegar: 4 DOF (oposiÃ§Ã£o completa)
  - Indicador: 3 DOF
  - MÃ©dio: 3 DOF
  - Anelar: 3 DOF (acoplado com mÃ­nimo)
  - MÃ­nimo: 3 DOF (acoplado com anelar)
  - Pulso: 2 DOF (pitch, yaw)

**Total sistema:** 43 DOF

**Custo:** +$8,000 USD
**Uso:** ManipulaÃ§Ã£o fina, grasping complexo, interaÃ§Ã£o social

</TabItem>
<TabItem value="custom" label="âš™ï¸ Custom Configuration">

**OpÃ§Ãµes modulares:**
- Force/torque sensors (braÃ§os): +$2,000
- LiDAR (Livox Mid-360): +$1,500
- Stereo camera extra (frontal): +$400
- Extended battery pack (2x): +$1,200

**IntegraÃ§Ã£o de terceiros:**
- Franka Emika gripper (compatÃ­vel)
- Robotic hands (Shadow, Allegro)
- Custom end-effectors via adaptador

</TabItem>
</Tabs>

---

## ğŸ—ï¸ Arquitetura de Software do G1

### Stack Completa

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  User Applications (Python/C++)                        â”‚  â† Seu cÃ³digo aqui
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Unitree SDK (unitree_sdk2_python / unitree_sdk2)     â”‚  â† APIs oficiais
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  DDS Middleware (Cyclone DDS)                          â”‚  â† ComunicaÃ§Ã£o
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Robot State Manager (RSM)                             â”‚  â† EstimaÃ§Ã£o de estados
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Motion Controllers                                     â”‚  â† LocomoÃ§Ã£o, balanÃ§o
â”‚  - Whole-Body Controller (WBC)                         â”‚
â”‚  - Gait Generator                                       â”‚
â”‚  - Balance Controller                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Low-Level Control (LLC)                               â”‚  â† Controle de motores
â”‚  - PID Controllers (23-43 joints)                      â”‚
â”‚  - Torque/Position modes                               â”‚
â”‚  - Safety limits                                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Hardware Abstraction Layer (HAL)                      â”‚  â† Drivers
â”‚  - Motor drivers (CAN bus)                             â”‚
â”‚  - Sensor drivers (I2C, SPI)                           â”‚
â”‚  - Camera interface (USB 3.0)                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Unitree SDK vs ROS2: Quando Usar Cada Um?

<Tabs>
<TabItem value="unitree-sdk" label="ğŸ”· Unitree SDK (Recomendado)">

**Vantagens:**
- âœ… **Performance:** LatÃªncia &lt; 1ms (DDS direto)
- âœ… **Simplicidade:** APIs especÃ­ficas do G1
- âœ… **DocumentaÃ§Ã£o:** Exemplos oficiais Unitree
- âœ… **Suporte:** Garantido pela Unitree
- âœ… **Updates:** Novos recursos liberados primeiro aqui

**Desvantagens:**
- âŒ Ecossistema menor (vs ROS2)
- âŒ Ferramentas de debug limitadas
- âŒ IntegraÃ§Ã£o com Nav2/MoveIt requer bridge

**Quando usar:**
- Controle de baixo nÃ­vel (motores, sensores)
- LocomoÃ§Ã£o customizada
- Performance crÃ­tica (&lt; 5ms latency)
- Prototipagem rÃ¡pida com G1

**Exemplo tÃ­pico:**
```python
from unitree_sdk2_python import G1Robot

robot = G1Robot()
robot.set_joint_position("left_knee", 0.5)  # Direto
```

</TabItem>
<TabItem value="ros2" label="ğŸ”¶ ROS2 Bridge">

**Vantagens:**
- âœ… **Ecossistema:** Nav2, MoveIt, Gazebo, etc.
- âœ… **Ferramentas:** RViz, rqt, rosbag
- âœ… **Comunidade:** Milhares de packages
- âœ… **PadrÃ£o:** Interoperabilidade com outros robÃ´s
- âœ… **Debugging:** TÃ³picos visualizÃ¡veis em tempo real

**Desvantagens:**
- âŒ LatÃªncia maior (~5-10ms overhead)
- âŒ Complexidade adicional (bridge)
- âŒ NÃ£o Ã© oficial Unitree (community-driven)

**Quando usar:**
- NavegaÃ§Ã£o autÃ´noma (Nav2)
- ManipulaÃ§Ã£o complexa (MoveIt2)
- IntegraÃ§Ã£o com sistemas ROS existentes
- SimulaÃ§Ã£o (Gazebo/Isaac Sim)

**Exemplo tÃ­pico:**
```python
import rclpy
from sensor_msgs.msg import JointState

# Publica via ROS2, bridge converte para Unitree SDK
pub.publish(JointState(...))
```

</TabItem>
<TabItem value="hybrid" label="ğŸ”€ HÃ­brido (Best of Both)">

**Arquitetura recomendada:**

```python
# Low-level control: Unitree SDK (performance)
from unitree_sdk2_python import G1Robot
robot = G1Robot()

# High-level planning: ROS2 (ecosystem)
import rclpy
from nav2_simple_commander import BasicNavigator

# Bridge manual quando necessÃ¡rio
def ros_to_unitree(joint_state_msg):
    for name, pos in zip(joint_state_msg.name, joint_state_msg.position):
        robot.set_joint_position(name, pos)
```

**BenefÃ­cios:**
- âš¡ Performance de Unitree SDK
- ğŸ› ï¸ Ferramentas de ROS2
- ğŸ¯ Melhor de ambos mundos

**Trade-off:** Complexidade de manter dois sistemas

</TabItem>
</Tabs>

**RecomendaÃ§Ã£o deste curso:** ComeÃ§ar com **Unitree SDK puro**, migrar para hÃ­brido se necessÃ¡rio.

---

## ğŸ“¦ InstalaÃ§Ã£o do Unitree SDK

### PrÃ©-Requisitos

```bash
# Sistema: Ubuntu 22.04
# Python: 3.10+
# EspaÃ§o em disco: 5GB

# Verificar versÃ£o Python
python3 --version  # Deve ser >= 3.10

# Instalar dependÃªncias do sistema
sudo apt update
sudo apt install -y \
  build-essential \
  cmake \
  git \
  python3-pip \
  python3-dev \
  libboost-all-dev \
  libeigen3-dev \
  libssl-dev
```

### InstalaÃ§Ã£o do SDK Python

<Tabs>
<TabItem value="pip" label="ğŸ Via pip (Recomendado)">

```bash
# Instalar unitree_sdk2_python
pip3 install unitree_sdk2_python

# Verificar instalaÃ§Ã£o
python3 -c "import unitree_sdk2_python; print(unitree_sdk2_python.__version__)"
# Output esperado: 1.2.3 (ou superior)

# Instalar pacotes auxiliares
pip3 install numpy scipy matplotlib
```

**Vantagens:**
- âœ… InstalaÃ§Ã£o rÃ¡pida (1 minuto)
- âœ… AtualizaÃ§Ãµes automÃ¡ticas via pip
- âœ… Gerenciamento de dependÃªncias

**LimitaÃ§Ãµes:**
- âŒ VersÃ£o pode estar defasada (~1 mÃªs)
- âŒ NÃ£o permite modificar cÃ³digo-fonte

</TabItem>
<TabItem value="source" label="ğŸ”§ From Source (AvanÃ§ado)">

```bash
# Clonar repositÃ³rio oficial
mkdir -p ~/unitree_sdk2
cd ~/unitree_sdk2
git clone https://github.com/unitreerobotics/unitree_sdk2.git

# Build C++ core
cd unitree_sdk2
mkdir build && cd build
cmake ..
make -j$(nproc)
sudo make install

# Build Python bindings
cd ../python
pip3 install -e .

# Verificar
python3 -c "import unitree_sdk2_python; print('OK')"
```

**Vantagens:**
- âœ… VersÃ£o mais recente (bleeding edge)
- âœ… Pode modificar cÃ³digo-fonte
- âœ… Acesso a features experimentais

**Desvantagens:**
- âŒ Build demorado (~10 min)
- âŒ Requer conhecimento de CMake
- âŒ AtualizaÃ§Ãµes manuais (git pull)

</TabItem>
<TabItem value="docker" label="ğŸ³ Docker (Isolado)">

```dockerfile
# Dockerfile para G1 development
FROM ubuntu:22.04

# Install dependencies
RUN apt update && apt install -y \
    python3-pip \
    git \
    build-essential \
    cmake

# Install Unitree SDK
RUN pip3 install unitree_sdk2_python numpy scipy

# Set working directory
WORKDIR /workspace

CMD ["/bin/bash"]
```

```bash
# Build image
docker build -t unitree-g1-dev .

# Run container
docker run -it --net=host \
  -v $(pwd):/workspace \
  unitree-g1-dev
```

**Vantagens:**
- âœ… Ambiente isolado (nÃ£o afeta sistema)
- âœ… ReproduzÃ­vel (mesmo ambiente sempre)
- âœ… FÃ¡cil compartilhar com equipe

**Desvantagens:**
- âŒ Overhead de performance (~5%)
- âŒ Network configuration complexa (DDS)
- âŒ USB devices requerem --privileged

</TabItem>
</Tabs>

---

## ğŸ”Œ Conectando ao G1

### MÃ©todos de ConexÃ£o

<Tabs>
<TabItem value="wifi" label="ğŸ“¡ WiFi (PadrÃ£o)">

**Setup inicial:**

```bash
# 1. Ligar G1 e aguardar 30s (boot completo)
# 2. Conectar ao WiFi "Unitree_G1_XXXX" (XXXX = serial)
#    Senha padrÃ£o: unitree123

# 3. Verificar conexÃ£o
ping 192.168.123.10  # IP padrÃ£o do G1
# Deve responder com latÃªncia < 5ms

# 4. SSH para verificar sistema
ssh unitree@192.168.123.10
# Senha: unitree
```

**Configurar IP estÃ¡tico (seu PC):**

```bash
# Ubuntu: Editar conexÃ£o WiFi
# Settings > WiFi > Unitree_G1_XXXX > IPv4
# Method: Manual
# Address: 192.168.123.100
# Netmask: 255.255.255.0
# Gateway: 192.168.123.1
```

**Vantagens:**
- âœ… Mobilidade (sem cabos)
- âœ… Setup rÃ¡pido
- âœ… MÃºltiplos clientes simultÃ¢neos

**Desvantagens:**
- âŒ LatÃªncia variÃ¡vel (2-10ms)
- âŒ PossÃ­vel interferÃªncia
- âŒ SeguranÃ§a (WiFi aberto por padrÃ£o)

</TabItem>
<TabItem value="ethernet" label="ğŸ”Œ Ethernet (Performance)">

**Setup:**

```bash
# 1. Conectar cabo Ethernet (porta traseira do G1)
# 2. Configurar IP estÃ¡tico no PC

# Ubuntu (via netplan):
sudo nano /etc/netplan/01-ethernet.yaml
```

```yaml
network:
  version: 2
  ethernets:
    eth0:  # Ou enp0s31f6 (verifique com 'ip a')
      addresses:
        - 192.168.123.100/24
      routes:
        - to: 192.168.123.0/24
          via: 192.168.123.1
      nameservers:
        addresses: [8.8.8.8]
```

```bash
sudo netplan apply

# Verificar conexÃ£o
ping 192.168.123.10
```

**Vantagens:**
- âœ… LatÃªncia consistente (&lt; 1ms)
- âœ… Largura de banda total (1 Gbps)
- âœ… Mais estÃ¡vel que WiFi
- âœ… Seguro (conexÃ£o direta)

**Desvantagens:**
- âŒ Cabo limita mobilidade
- âŒ Risco de tropeÃ§ar no cabo
- âŒ Requer porta Ethernet no PC

**Recomendado para:** Desenvolvimento, debugging, treinamento RL

</TabItem>
<TabItem value="remote" label="ğŸŒ Remote (Cloud)">

**Setup com Tailscale VPN:**

```bash
# No G1 (via SSH):
ssh unitree@192.168.123.10
curl -fsSL https://tailscale.com/install.sh | sh
sudo tailscale up

# No seu PC:
curl -fsSL https://tailscale.com/install.sh | sh
sudo tailscale up

# Agora vocÃª tem IP persistente (ex: 100.64.0.1)
ping 100.64.0.1  # Funciona de qualquer lugar!
```

**Vantagens:**
- âœ… Acesso de qualquer lugar (internet)
- âœ… Seguro (WireGuard encrypted)
- âœ… IP fixo (nÃ£o muda)
- âœ… MÃºltiplos G1s facilmente

**Desvantagens:**
- âŒ LatÃªncia alta (50-200ms)
- âŒ Requer internet no G1
- âŒ âŒ **NÃƒO USAR PARA CONTROLE EM TEMPO REAL**

**Uso:** Monitoramento, coleta de logs, atualizaÃ§Ãµes OTA

</TabItem>
</Tabs>

---

## ğŸš€ Primeira API Call: Hello G1

### Exemplo Completo (Python)

```python
#!/usr/bin/env python3
"""
hello_g1.py - Primeiro programa com Unitree G1
Conecta ao robÃ´ e lÃª estados bÃ¡sicos
"""

import time
from unitree_sdk2_python import G1Robot, RobotState

def main():
    print("ğŸ¤– Conectando ao Unitree G1...")

    # Inicializar robÃ´
    # network_interface: "wlan0" para WiFi, "eth0" para Ethernet
    robot = G1Robot(network_interface="wlan0")

    # Aguardar conexÃ£o (timeout 10s)
    if not robot.wait_for_connection(timeout=10.0):
        print("âŒ Falha ao conectar. Verifique:")
        print("  - G1 estÃ¡ ligado?")
        print("  - Conectado na mesma rede?")
        print("  - IP correto? (ping 192.168.123.10)")
        return

    print("âœ… Conectado com sucesso!\n")

    # Ler estado do robÃ´
    state = robot.get_state()

    # InformaÃ§Ãµes bÃ¡sicas
    print("=" * 60)
    print("INFORMAÃ‡Ã•ES DO ROBÃ”")
    print("=" * 60)
    print(f"Modelo: {state.robot_model}")
    print(f"Serial: {state.serial_number}")
    print(f"Firmware: {state.firmware_version}")
    print(f"Uptime: {state.uptime / 3600:.1f} horas")
    print(f"Bateria: {state.battery_percentage}% ({state.battery_voltage:.1f}V)")
    print(f"Temperatura CPU: {state.cpu_temperature}Â°C")
    print(f"Modo atual: {state.control_mode}")
    print()

    # Estados das juntas
    print("=" * 60)
    print("ESTADOS DAS JUNTAS (primeiras 6)")
    print("=" * 60)
    print(f"{'Junta':<20} {'PosiÃ§Ã£o (rad)':<15} {'Velocidade':<15} {'Torque (Nm)'}")
    print("-" * 60)

    for i, joint_name in enumerate(state.joint_names[:6]):
        pos = state.joint_positions[i]
        vel = state.joint_velocities[i]
        tau = state.joint_torques[i]
        print(f"{joint_name:<20} {pos:>13.3f}   {vel:>13.3f}   {tau:>13.2f}")

    print()

    # OrientaÃ§Ã£o (IMU)
    print("=" * 60)
    print("ORIENTAÃ‡ÃƒO (IMU)")
    print("=" * 60)
    roll, pitch, yaw = state.imu_euler  # Roll, Pitch, Yaw em radianos
    print(f"Roll:  {roll * 57.3:>6.1f}Â° (inclinaÃ§Ã£o lateral)")
    print(f"Pitch: {pitch * 57.3:>6.1f}Â° (inclinaÃ§Ã£o frente/trÃ¡s)")
    print(f"Yaw:   {yaw * 57.3:>6.1f}Â° (rotaÃ§Ã£o)")
    print()

    # ForÃ§as nos pÃ©s
    print("=" * 60)
    print("FORÃ‡AS NOS PÃ‰S")
    print("=" * 60)
    print(f"PÃ© esquerdo: {state.left_foot_force:>6.1f} N")
    print(f"PÃ© direito:  {state.right_foot_force:>6.1f} N")
    print(f"Total:       {state.left_foot_force + state.right_foot_force:>6.1f} N")
    print(f"(Peso esperado: ~540 N para 55kg)")
    print()

    # Monitor contÃ­nuo (10 segundos)
    print("=" * 60)
    print("MONITORAMENTO EM TEMPO REAL (10s)")
    print("=" * 60)
    print("Pressione Ctrl+C para interromper")
    print()

    try:
        for i in range(100):  # 100 iteraÃ§Ãµes, 10 Hz
            state = robot.get_state()

            # Atualizar linha (sem criar nova)
            print(f"\rBat: {state.battery_percentage:>3}% | "
                  f"CPU: {state.cpu_temperature:>4.1f}Â°C | "
                  f"IMU Pitch: {state.imu_euler[1] * 57.3:>5.1f}Â° | "
                  f"ForÃ§as: L={state.left_foot_force:>5.1f}N R={state.right_foot_force:>5.1f}N",
                  end='', flush=True)

            time.sleep(0.1)  # 10 Hz

    except KeyboardInterrupt:
        print("\n\nâš ï¸  Interrompido pelo usuÃ¡rio")

    print("\n")
    print("=" * 60)
    print("âœ… Teste concluÃ­do com sucesso!")
    print("=" * 60)

    # Desconectar
    robot.disconnect()
    print("ğŸ”Œ Desconectado do G1")

if __name__ == "__main__":
    main()
```

**Executar:**

```bash
python3 hello_g1.py
```

**Output esperado:**

```
ğŸ¤– Conectando ao Unitree G1...
âœ… Conectado com sucesso!

============================================================
INFORMAÃ‡Ã•ES DO ROBÃ”
============================================================
Modelo: Unitree G1
Serial: G1-2024-A0123
Firmware: 1.2.3
Uptime: 2.3 horas
Bateria: 87% (49.2V)
Temperatura CPU: 45.3Â°C
Modo atual: IDLE

============================================================
ESTADOS DAS JUNTAS (primeiras 6)
============================================================
Junta                PosiÃ§Ã£o (rad)   Velocidade      Torque (Nm)
------------------------------------------------------------
left_hip_pitch               0.123         0.001          0.50
left_hip_roll                0.045        -0.002          0.30
left_hip_yaw                -0.002         0.000          0.10
left_knee                    0.567         0.003          2.40
left_ankle_pitch             0.234        -0.001          1.20
left_ankle_roll              0.012         0.000          0.50

============================================================
ORIENTAÃ‡ÃƒO (IMU)
============================================================
Roll:     1.2Â° (inclinaÃ§Ã£o lateral)
Pitch:    0.8Â° (inclinaÃ§Ã£o frente/trÃ¡s)
Yaw:    45.3Â° (rotaÃ§Ã£o)

============================================================
FORÃ‡AS NOS PÃ‰S
============================================================
PÃ© esquerdo:  265.3 N
PÃ© direito:   271.8 N
Total:        537.1 N
(Peso esperado: ~540 N para 55kg)

============================================================
MONITORAMENTO EM TEMPO REAL (10s)
============================================================
Pressione Ctrl+C para interromper

Bat:  87% | CPU: 45.3Â°C | IMU Pitch:   0.8Â° | ForÃ§as: L=265.1N R=271.9N

============================================================
âœ… Teste concluÃ­do com sucesso!
============================================================
ğŸ”Œ Desconectado do G1
```

---

## ğŸ“š Estrutura das APIs

### Classes Principais

```python
from unitree_sdk2_python import (
    G1Robot,          # Classe principal do robÃ´
    RobotState,       # Estado completo do robÃ´
    JointCommand,     # Comando para juntas
    MotionCommand,    # Comando de movimento
    SensorData,       # Dados de sensores
    ControlMode       # Modos de controle
)
```

### G1Robot API Reference

```python
class G1Robot:
    def __init__(self, network_interface="wlan0"):
        """
        Inicializa conexÃ£o com G1

        Args:
            network_interface: "wlan0" (WiFi) ou "eth0" (Ethernet)
        """
        pass

    def wait_for_connection(self, timeout=10.0) -> bool:
        """Aguarda conexÃ£o (timeout em segundos)"""
        pass

    def get_state(self) -> RobotState:
        """Retorna estado atual completo"""
        pass

    def set_joint_position(self, joint_name: str, position: float):
        """Define posiÃ§Ã£o de junta (modo POSITION)"""
        pass

    def set_joint_velocity(self, joint_name: str, velocity: float):
        """Define velocidade de junta (modo VELOCITY)"""
        pass

    def set_joint_torque(self, joint_name: str, torque: float):
        """Define torque de junta (modo TORQUE)"""
        pass

    def set_control_mode(self, mode: ControlMode):
        """Altera modo de controle global"""
        pass

    def emergency_stop(self):
        """PARA TUDO IMEDIATAMENTE"""
        pass

    def disconnect(self):
        """Desconecta gracefully"""
        pass
```

### RobotState Attributes

```python
class RobotState:
    # IdentificaÃ§Ã£o
    robot_model: str           # "Unitree G1"
    serial_number: str         # "G1-2024-A0123"
    firmware_version: str      # "1.2.3"

    # Sistema
    uptime: float              # Segundos desde boot
    cpu_temperature: float     # Celsius
    battery_percentage: float  # 0-100%
    battery_voltage: float     # Volts (nominal 48V)
    battery_current: float     # Amperes

    # Juntas (arrays de tamanho 23 ou 43)
    joint_names: list[str]         # ["left_hip_pitch", ...]
    joint_positions: list[float]   # Radianos
    joint_velocities: list[float]  # Rad/s
    joint_torques: list[float]     # Newton-metros
    joint_temperatures: list[float] # Celsius

    # IMU (Inertial Measurement Unit)
    imu_quaternion: tuple[float, float, float, float]  # (w, x, y, z)
    imu_euler: tuple[float, float, float]              # (roll, pitch, yaw) rad
    imu_angular_velocity: tuple[float, float, float]   # (wx, wy, wz) rad/s
    imu_linear_acceleration: tuple[float, float, float] # (ax, ay, az) m/sÂ²

    # ForÃ§as nos pÃ©s
    left_foot_force: float     # Newtons (total vertical)
    right_foot_force: float    # Newtons (total vertical)
    left_foot_torque: tuple[float, float, float]  # (tx, ty, tz) Nm
    right_foot_torque: tuple[float, float, float] # (tx, ty, tz) Nm

    # Modo de controle
    control_mode: str          # "IDLE", "POSITION", "VELOCITY", "TORQUE"

    # Timestamp
    timestamp: float           # Unix epoch (segundos)
```

---

## ğŸ® Modos de Controle

<Tabs>
<TabItem value="idle" label="â¸ï¸ IDLE">

**DescriÃ§Ã£o:** Motores desligados, juntas livres (gravity compensation ativa)

**Quando usar:**
- ApÃ³s ligar o robÃ´
- Para mover juntas manualmente
- Emergency stop recovery
- Trocar bateria

**Exemplo:**

```python
robot.set_control_mode(ControlMode.IDLE)
# Agora vocÃª pode mover os braÃ§os manualmente
print("RobÃ´ em modo IDLE - juntas livres")
```

**âš ï¸ AtenÃ§Ã£o:** G1 pode cair se nÃ£o estiver apoiado!

</TabItem>
<TabItem value="position" label="ğŸ“ POSITION">

**DescriÃ§Ã£o:** Controle de posiÃ§Ã£o das juntas (PID interno)

**Quando usar:**
- Movimentos lentos e precisos
- Poses estÃ¡ticas
- ManipulaÃ§Ã£o de objetos
- Iniciantes (modo mais seguro)

**Exemplo:**

```python
robot.set_control_mode(ControlMode.POSITION)

# Dobrar joelho esquerdo para 90 graus
robot.set_joint_position("left_knee", 1.57)  # 1.57 rad = 90Â°

# Mover braÃ§o para posiÃ§Ã£o home
robot.set_joint_position("left_shoulder_pitch", 0.0)
robot.set_joint_position("left_elbow", 0.0)
```

**Limites:**
- Velocidade mÃ¡xima: 2 rad/s (configurÃ¡vel)
- AceleraÃ§Ã£o: 5 rad/sÂ² (configurÃ¡vel)
- Erro mÃ¡ximo permitido: 0.1 rad

</TabItem>
<TabItem value="velocity" label="ğŸš„ VELOCITY">

**DescriÃ§Ã£o:** Controle de velocidade das juntas

**Quando usar:**
- Movimentos contÃ­nuos
- Jogging manual
- Tracking de trajetÃ³rias dinÃ¢micas

**Exemplo:**

```python
robot.set_control_mode(ControlMode.VELOCITY)

# Rotacionar quadril continuamente
robot.set_joint_velocity("left_hip_yaw", 0.5)  # 0.5 rad/s

# Parar apÃ³s 2 segundos
time.sleep(2.0)
robot.set_joint_velocity("left_hip_yaw", 0.0)
```

**Limites:**
- Velocidade mÃ¡xima: 5 rad/s (safety limit)
- AceleraÃ§Ã£o: automÃ¡tica (suavizada)

</TabItem>
<TabItem value="torque" label="âš¡ TORQUE">

**DescriÃ§Ã£o:** Controle direto de torque (forÃ§a)

**Quando usar:**
- Controle de impedÃ¢ncia
- Force feedback
- Algoritmos de controle customizados
- Aprendizado por reforÃ§o

**Exemplo:**

```python
robot.set_control_mode(ControlMode.TORQUE)

# Aplicar torque no joelho (gravity compensation)
robot.set_joint_torque("left_knee", 5.0)  # 5 Nm

# CUIDADO: Sem PID interno!
# VocÃª Ã© responsÃ¡vel por estabilidade
```

**âš ï¸ PERIGOSO:** Pode causar movimentos bruscos ou queda se mal configurado!

**Limites:**
- Torque mÃ¡ximo: Depende da junta (5-45 Nm)
- Sem proteÃ§Ã£o automÃ¡tica (vocÃª implementa)

</TabItem>
</Tabs>

---

## ğŸ” Joint Names Reference

### Pernas (12 DOF)

```python
# Perna esquerda (6 DOF)
LEFT_LEG_JOINTS = [
    "left_hip_pitch",      # Quadril frente/trÃ¡s: -0.8 a 1.6 rad
    "left_hip_roll",       # Quadril lateral: -0.5 a 0.5 rad
    "left_hip_yaw",        # Quadril rotaÃ§Ã£o: -0.3 a 0.3 rad
    "left_knee",           # Joelho: 0.0 a 2.3 rad (nÃ£o dobra reverso)
    "left_ankle_pitch",    # Tornozelo frente/trÃ¡s: -0.7 a 0.7 rad
    "left_ankle_roll"      # Tornozelo lateral: -0.3 a 0.3 rad
]

# Perna direita (6 DOF) - simÃ©trica
RIGHT_LEG_JOINTS = [
    "right_hip_pitch",
    "right_hip_roll",
    "right_hip_yaw",
    "right_knee",
    "right_ankle_pitch",
    "right_ankle_roll"
]
```

### BraÃ§os (7 DOF)

```python
# BraÃ§o esquerdo (3.5 DOF - gripper conta como 0.5)
LEFT_ARM_JOINTS = [
    "left_shoulder_pitch",  # Ombro frente/trÃ¡s: -3.0 a 3.0 rad
    "left_shoulder_roll",   # Ombro lateral: -1.5 a 1.5 rad
    "left_elbow",           # Cotovelo: 0.0 a 2.6 rad
    "left_wrist_yaw"        # Pulso rotaÃ§Ã£o: -3.0 a 3.0 rad (continuous)
]

# BraÃ§o direito (3.5 DOF)
RIGHT_ARM_JOINTS = [
    "right_shoulder_pitch",
    "right_shoulder_roll",
    "right_elbow",
    "right_wrist_yaw"
]
```

### Torso (4 DOF)

```python
TORSO_JOINTS = [
    "waist_pitch",    # Cintura frente/trÃ¡s: -0.4 a 0.4 rad
    "waist_yaw",      # Cintura rotaÃ§Ã£o: -0.8 a 0.8 rad
    "neck_pitch",     # PescoÃ§o frente/trÃ¡s: -0.6 a 0.6 rad
    "neck_yaw"        # PescoÃ§o rotaÃ§Ã£o: -1.2 a 1.2 rad
]
```

### Dexterous Hands (20 DOF adicionais)

```python
# MÃ£o esquerda (10 DOF)
LEFT_HAND_JOINTS = [
    # Polegar (4 DOF - oposiÃ§Ã£o completa)
    "left_thumb_cmc_abduction",    # Base: abd/add
    "left_thumb_cmc_flexion",      # Base: flex/ext
    "left_thumb_mcp",              # MÃ©dia
    "left_thumb_ip",               # Ponta

    # Indicador (3 DOF)
    "left_index_mcp",
    "left_index_pip",
    "left_index_dip",

    # MÃ©dio (3 DOF)
    "left_middle_mcp",
    "left_middle_pip",
    "left_middle_dip"

    # Ring e pinky sÃ£o acoplados (omitido por brevidade)
]

# MÃ£o direita (10 DOF) - simÃ©trica
```

---

## ğŸ› ï¸ Troubleshooting

### Problema 1: Connection timeout

**Erro:**
```
âŒ Falha ao conectar. Timeout apÃ³s 10s
```

**Checklist:**
1. G1 estÃ¡ ligado? (LED verde na parte traseira)
2. Conectado na mesma rede? (WiFi Unitree_G1_XXXX ou Ethernet)
3. Ping funciona? `ping 192.168.123.10`
4. Firewall bloqueando? `sudo ufw status`
5. DDS configurado? Verificar `RMW_IMPLEMENTATION`

**SoluÃ§Ã£o:**

```bash
# Verificar conectividade
ping -c 5 192.168.123.10

# Se ping falha: problema de rede
# Se ping funciona mas SDK falha: problema DDS

# Configurar Cyclone DDS
export RMW_IMPLEMENTATION=rmw_cyclonedds_cpp
export CYCLONEDDS_URI='<CycloneDDS><Domain><General><NetworkInterfaceAddress>auto</NetworkInterfaceAddress></General></Domain></CycloneDDS>'
```

---

### Problema 2: Permission denied (network interface)

**Erro:**
```
PermissionError: [Errno 13] Permission denied: 'wlan0'
```

**SoluÃ§Ã£o:**

```bash
# Adicionar usuÃ¡rio ao grupo netdev
sudo usermod -a -G netdev $USER

# Logout e login novamente, ou:
newgrp netdev

# Rodar com sudo (nÃ£o recomendado para produÃ§Ã£o)
sudo python3 hello_g1.py
```

---

### Problema 3: Joint limits exceeded

**Erro:**
```
RuntimeError: Joint 'left_knee' position 3.0 exceeds limit [0.0, 2.3]
```

**SoluÃ§Ã£o:**

```python
# Sempre verificar limites antes de comandar
def safe_set_joint(robot, joint_name, target_pos):
    limits = robot.get_joint_limits(joint_name)

    # Clamp para limites
    safe_pos = max(limits.min, min(limits.max, target_pos))

    if safe_pos != target_pos:
        print(f"âš ï¸  {joint_name}: {target_pos:.2f} clamped to {safe_pos:.2f}")

    robot.set_joint_position(joint_name, safe_pos)

# Uso:
safe_set_joint(robot, "left_knee", 3.0)  # SerÃ¡ clamped para 2.3
```

---

## âœ… Checklist de ConclusÃ£o

- [ ] Unitree SDK instalado (`python3 -c "import unitree_sdk2_python"` funciona)
- [ ] G1 conectado via WiFi ou Ethernet (ping bem-sucedido)
- [ ] hello_g1.py executado com sucesso
- [ ] Entendi os 4 modos de controle (IDLE, POSITION, VELOCITY, TORQUE)
- [ ] ConheÃ§o todos os joint names (23 ou 43 DOF)
- [ ] Testei ler estados em tempo real (bateria, IMU, forÃ§as)
- [ ] Compreendi diferenÃ§a entre Unitree SDK e ROS2

---

## ğŸ”— PrÃ³ximos Passos

:::tip PrÃ³ximo MÃ³dulo
**[ğŸ“¡ ComunicaÃ§Ã£o DDS com G1 â†’](./comunicacao-dds)**

Aprofunde-se no Cyclone DDS: topics, QoS, network debugging e otimizaÃ§Ã£o de latÃªncia.
:::

**Recursos adicionais:**
- [Unitree SDK Docs](https://support.unitree.com/home/en/developer/SDK)
- [Cyclone DDS Guide](https://github.com/eclipse-cyclonedds/cyclonedds)
- [G1 Hardware Manual (PDF)](https://www.unitree.com/download/g1_manual.pdf)

---

**â±ï¸ Tempo estimado:** 50-70 min
**ğŸ§  NÃ­vel:** IntermediÃ¡rio
**ğŸ’» Hands-on:** 80% prÃ¡tico, 20% teÃ³rico
