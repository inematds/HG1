---
sidebar_position: 6
title: 6. ManipulaÃ§Ã£o com BraÃ§os do G1
description: Arm kinematics, gripper control, pick and place e force control
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# ğŸ¦¾ ManipulaÃ§Ã£o com BraÃ§os do Unitree G1

:::tip Objetivo do MÃ³dulo
Dominar o controle dos braÃ§os do G1: forward/inverse kinematics, controle das mÃ£os dexterous, implementar pick and place, e force control para manipulaÃ§Ã£o delicada.
:::

---

## ğŸ¦¾ Anatomia dos BraÃ§os do G1

### Hardware Specifications

<Tabs>
<TabItem value="standard" label="ğŸ”§ Standard Arms (3.5 DOF)">

**ComposiÃ§Ã£o:**

```
Ombro (Shoulder):
â”œâ”€ Pitch: -3.0 a 3.0 rad (-172Â° a 172Â°)
â”‚  Torque mÃ¡ximo: 25 Nm
â”‚  Velocidade mÃ¡xima: 8 rad/s
â”‚
â””â”€ Roll: -1.5 a 1.5 rad (-86Â° a 86Â°)
   Torque mÃ¡ximo: 20 Nm
   Velocidade mÃ¡xima: 8 rad/s

Cotovelo (Elbow):
â””â”€ Pitch: 0.0 a 2.6 rad (0Â° a 149Â°)
   Torque mÃ¡ximo: 20 Nm
   Velocidade mÃ¡xima: 10 rad/s

Pulso (Wrist):
â””â”€ Yaw: -3.0 a 3.0 rad (continuous rotation)
   Torque mÃ¡ximo: 10 Nm
   Velocidade mÃ¡xima: 15 rad/s

Gripper (Garra):
â””â”€ Parallel jaw, abertura: 0 - 0.08m (8cm)
   ForÃ§a de preensÃ£o: 50 N
```

**Workspace:**
- Alcance mÃ¡ximo: 0.75m (braÃ§o estendido)
- Workspace volume: ~0.8 mÂ³
- Payload: 2 kg (braÃ§o estendido), 5 kg (prÃ³ximo ao corpo)

</TabItem>
<TabItem value="dexterous" label="âœ‹ Dexterous Hands (10 DOF)">

**ComposiÃ§Ã£o de cada mÃ£o:**

```
Polegar (4 DOF - oposiÃ§Ã£o completa):
â”œâ”€ CMC Abduction: -0.5 a 0.5 rad
â”œâ”€ CMC Flexion: -0.3 a 1.0 rad
â”œâ”€ MCP: -0.2 a 1.2 rad
â””â”€ IP: -0.2 a 1.0 rad

Indicador (3 DOF):
â”œâ”€ MCP: -0.2 a 1.5 rad
â”œâ”€ PIP: 0.0 a 1.8 rad
â””â”€ DIP: 0.0 a 1.5 rad (acoplado com PIP, ratio 2:3)

MÃ©dio (3 DOF):
â”œâ”€ MCP: -0.2 a 1.5 rad
â”œâ”€ PIP: 0.0 a 1.8 rad
â””â”€ DIP: 0.0 a 1.5 rad

Anelar + MÃ­nimo (acoplados, 2 DOF efetivos):
â””â”€ Movem juntos para power grasp
```

**Capabilities:**
- Precision grasp (pinÃ§a: polegar + indicador)
- Power grasp (envolver objeto)
- Gestures (apontar, ok, thumbs up, etc.)

**Sensores:**
- Tactile sensors nas pontas (10 N range)
- Torque feedback em todas juntas

</TabItem>
</Tabs>

---

## ğŸ“ Forward Kinematics

### DefiniÃ§Ã£o DH Parameters

```python
#!/usr/bin/env python3
"""
forward_kinematics.py - FK do braÃ§o G1
"""

import numpy as np
from dataclasses import dataclass

@dataclass
class DHParameter:
    """Denavit-Hartenberg parameters"""
    a: float      # Link length
    alpha: float  # Link twist
    d: float      # Link offset
    theta: float  # Joint angle

class G1ArmFK:
    def __init__(self, arm="left"):
        """
        Forward Kinematics do braÃ§o G1

        DH Parameters (simplificado - 4 DOF: shoulder_pitch, shoulder_roll, elbow, wrist)
        """
        self.arm = arm

        # Comprimentos dos links (aproximados)
        self.L_shoulder = 0.15  # Ombro ao cotovelo [m]
        self.L_upper_arm = 0.30  # BraÃ§o superior
        self.L_forearm = 0.30    # AntebraÃ§o
        self.L_hand = 0.10       # MÃ£o

    def compute_fk(self, joint_angles: dict) -> np.ndarray:
        """
        Calcula posiÃ§Ã£o do end-effector

        Args:
            joint_angles: dict com {joint_name: angle_rad}

        Returns:
            4x4 transformation matrix (homogeneous)
        """
        # Extrair Ã¢ngulos
        shoulder_pitch = joint_angles.get(f"{self.arm}_shoulder_pitch", 0.0)
        shoulder_roll = joint_angles.get(f"{self.arm}_shoulder_roll", 0.0)
        elbow = joint_angles.get(f"{self.arm}_elbow", 0.0)
        wrist_yaw = joint_angles.get(f"{self.arm}_wrist_yaw", 0.0)

        # DH parameters
        dh_params = [
            # a, alpha, d, theta
            DHParameter(0, np.pi/2, 0, shoulder_pitch),
            DHParameter(0, np.pi/2, self.L_shoulder, shoulder_roll),
            DHParameter(self.L_upper_arm, 0, 0, elbow),
            DHParameter(self.L_forearm, 0, 0, wrist_yaw)
        ]

        # Compute transformation matrices
        T = np.eye(4)

        for dh in dh_params:
            T_i = self._dh_matrix(dh)
            T = T @ T_i

        return T

    def _dh_matrix(self, dh: DHParameter) -> np.ndarray:
        """Compute DH transformation matrix"""
        ct = np.cos(dh.theta)
        st = np.sin(dh.theta)
        ca = np.cos(dh.alpha)
        sa = np.sin(dh.alpha)

        return np.array([
            [ct, -st*ca, st*sa, dh.a*ct],
            [st, ct*ca, -ct*sa, dh.a*st],
            [0, sa, ca, dh.d],
            [0, 0, 0, 1]
        ])

    def get_end_effector_pose(self, joint_angles: dict) -> dict:
        """
        Retorna posiÃ§Ã£o e orientaÃ§Ã£o do end-effector

        Returns:
            dict com 'position' (x, y, z) e 'rotation' (3x3 matrix)
        """
        T = self.compute_fk(joint_angles)

        position = T[:3, 3]
        rotation = T[:3, :3]

        return {
            "position": position,
            "rotation": rotation
        }

# Exemplo de uso:
def main():
    fk = G1ArmFK(arm="left")

    # ConfiguraÃ§Ã£o de exemplo
    joint_angles = {
        "left_shoulder_pitch": 0.5,  # 28.6Â°
        "left_shoulder_roll": 0.3,   # 17.2Â°
        "left_elbow": 1.0,            # 57.3Â°
        "left_wrist_yaw": 0.0
    }

    result = fk.get_end_effector_pose(joint_angles)

    print("End-effector position:")
    print(f"  x: {result['position'][0]:.3f} m")
    print(f"  y: {result['position'][1]:.3f} m")
    print(f"  z: {result['position'][2]:.3f} m")

    print("\nEnd-effector rotation:")
    print(result['rotation'])

if __name__ == "__main__":
    main()
```

---

## ğŸ¯ Inverse Kinematics

### Analytical IK (3 DOF)

```python
class G1ArmIK:
    def __init__(self, arm="left"):
        self.arm = arm
        self.fk = G1ArmFK(arm)

        # Link lengths
        self.L1 = 0.30  # Upper arm
        self.L2 = 0.30  # Forearm

    def compute_ik(self, target_position: np.ndarray) -> dict:
        """
        Analytical IK para posiÃ§Ã£o alvo (3D)

        Args:
            target_position: [x, y, z] em metros

        Returns:
            dict com joint angles ou None se nÃ£o alcanÃ§Ã¡vel
        """
        x, y, z = target_position

        # DistÃ¢ncia do ombro ao alvo (3D)
        r = np.sqrt(x**2 + y**2 + z**2)

        # Check reachability
        if r > (self.L1 + self.L2) or r < abs(self.L1 - self.L2):
            print(f"âŒ Alvo inalcanÃ§Ã¡vel: r={r:.3f}m, max={self.L1+self.L2:.3f}m")
            return None

        # Shoulder roll (lateral)
        shoulder_roll = np.arctan2(y, np.sqrt(x**2 + z**2))

        # ProjeÃ§Ã£o no plano x-z
        r_xz = np.sqrt(x**2 + z**2)

        # Elbow angle (lei dos cossenos)
        cos_elbow = (r_xz**2 - self.L1**2 - self.L2**2) / (2 * self.L1 * self.L2)
        cos_elbow = np.clip(cos_elbow, -1.0, 1.0)
        elbow = np.arccos(cos_elbow)

        # Shoulder pitch
        alpha = np.arctan2(z, x)
        beta = np.arcsin((self.L2 * np.sin(elbow)) / r_xz)
        shoulder_pitch = alpha - beta

        # Wrist (manter paralelo ao chÃ£o)
        wrist_yaw = 0.0

        return {
            f"{self.arm}_shoulder_pitch": shoulder_pitch,
            f"{self.arm}_shoulder_roll": shoulder_roll,
            f"{self.arm}_elbow": elbow,
            f"{self.arm}_wrist_yaw": wrist_yaw
        }

    def move_to_position(self, robot, target_position: np.ndarray, duration=2.0):
        """Move braÃ§o para posiÃ§Ã£o alvo"""
        # Compute IK
        joint_angles = self.compute_ik(target_position)

        if joint_angles is None:
            return False

        print(f"Moving {self.arm} arm to {target_position}")
        print(f"Joint angles: {joint_angles}")

        # Send commands
        for joint_name, angle in joint_angles.items():
            cmd = JointCommand()
            cmd.joint_name = joint_name
            cmd.control_mode = "POSITION"
            cmd.target_position = angle
            cmd.max_velocity = 1.0
            cmd.kp = 100.0
            cmd.kd = 5.0

            robot.send_command(cmd)

        # Wait for movement
        time.sleep(duration)
        return True

# Exemplo:
def main():
    robot = G1Robot()
    robot.wait_for_connection()

    ik = G1ArmIK(arm="left")

    # Mover para posiÃ§Ã£o na frente
    target = np.array([0.4, 0.2, 0.3])  # 40cm frente, 20cm esquerda, 30cm acima
    ik.move_to_position(robot, target, duration=2.0)

    robot.disconnect()
```

---

## ğŸ¤ Gripper Control

### Standard Gripper (Parallel Jaw)

```python
class GripperController:
    def __init__(self, robot: G1Robot, arm="left"):
        self.robot = robot
        self.arm = arm
        self.gripper_joint = f"{arm}_gripper"

        # Limites
        self.closed_position = 0.0    # Fechado
        self.open_position = 0.08     # Aberto (8cm)
        self.max_force = 50.0         # [N]

    def open(self, duration=1.0):
        """Abre garra completamente"""
        self._set_position(self.open_position, duration)

    def close(self, duration=1.0):
        """Fecha garra completamente"""
        self._set_position(self.closed_position, duration)

    def set_width(self, width: float, duration=1.0):
        """
        Define abertura especÃ­fica

        Args:
            width: Abertura em metros (0.0 - 0.08)
        """
        width = np.clip(width, self.closed_position, self.open_position)
        self._set_position(width, duration)

    def grasp(self, object_width: float = 0.05, force: float = 20.0):
        """
        Pega objeto com largura conhecida

        Args:
            object_width: Largura do objeto [m]
            force: ForÃ§a de preensÃ£o [N]
        """
        # Abrir mais que objeto
        self.set_width(object_width + 0.02, duration=0.5)
        time.sleep(0.6)

        # Fechar com controle de forÃ§a
        self._grasp_with_force(force)

    def _set_position(self, position: float, duration: float):
        """Envia comando de posiÃ§Ã£o"""
        cmd = JointCommand()
        cmd.joint_name = self.gripper_joint
        cmd.control_mode = "POSITION"
        cmd.target_position = position
        cmd.max_velocity = 0.1  # Devagar para seguranÃ§a

        self.robot.send_command(cmd)
        time.sleep(duration)

    def _grasp_with_force(self, target_force: float):
        """Fecha gripper atÃ© atingir forÃ§a alvo"""
        while True:
            state = self.robot.get_state()
            idx = state.joint_names.index(self.gripper_joint)
            current_torque = state.joint_torques[idx]

            # Converter torque para forÃ§a (simplificado)
            # F = Ï„ / r, onde r = raio da garra (~0.04m)
            current_force = abs(current_torque) / 0.04

            if current_force >= target_force:
                print(f"âœ… PreensÃ£o alcanÃ§ada: {current_force:.1f} N")
                break

            # Continuar fechando devagar
            current_pos = state.joint_positions[idx]
            self._set_position(current_pos - 0.001, duration=0.05)

            if current_pos <= self.closed_position:
                print("âš ï¸  Gripper completamente fechado")
                break

# Uso:
def test_gripper():
    robot = G1Robot()
    robot.wait_for_connection()

    gripper = GripperController(robot, arm="left")

    # Teste 1: Abrir/fechar
    gripper.open()
    time.sleep(1)
    gripper.close()
    time.sleep(1)

    # Teste 2: Pegar objeto de 5cm com 20N
    gripper.grasp(object_width=0.05, force=20.0)

    robot.disconnect()
```

### Dexterous Hand Control

```python
class DexterousHandController:
    def __init__(self, robot: G1Robot, arm="left"):
        self.robot = robot
        self.arm = arm

        # Joint names
        self.finger_joints = {
            "thumb": [f"{arm}_thumb_cmc_abduction", f"{arm}_thumb_cmc_flexion",
                      f"{arm}_thumb_mcp", f"{arm}_thumb_ip"],
            "index": [f"{arm}_index_mcp", f"{arm}_index_pip", f"{arm}_index_dip"],
            "middle": [f"{arm}_middle_mcp", f"{arm}_middle_pip", f"{arm}_middle_dip"],
            # Ring e pinky acoplados
        }

    def precision_grasp(self, object_diameter: float = 0.03):
        """
        PinÃ§a (polegar + indicador)

        Args:
            object_diameter: DiÃ¢metro do objeto [m]
        """
        # Posicionar polegar
        thumb_angles = [0.5, 0.8, 0.6, 0.4]  # ABD, FLEX, MCP, IP
        self._set_finger("thumb", thumb_angles)

        # Posicionar indicador
        index_angles = [0.6, 1.0, 0.7]  # MCP, PIP, DIP
        self._set_finger("index", index_angles)

        # Outros dedos abertos
        self._set_finger("middle", [0.0, 0.0, 0.0])

        print(f"âœ… Precision grasp para objeto {object_diameter*1000:.0f}mm")

    def power_grasp(self):
        """Power grasp (envolver objeto)"""
        # Todos os dedos fechados
        for finger in ["thumb", "index", "middle"]:
            if finger == "thumb":
                angles = [0.3, 1.0, 1.2, 1.0]  # Fechar polegar
            else:
                angles = [1.5, 1.8, 1.5]  # Fechar outros

            self._set_finger(finger, angles)

        print("âœ… Power grasp ativado")

    def point(self):
        """Gesto: apontar"""
        # Indicador estendido, outros fechados
        self._set_finger("index", [0.0, 0.0, 0.0])  # Aberto
        self._set_finger("thumb", [0.3, 0.8, 1.0, 0.8])
        self._set_finger("middle", [1.5, 1.8, 1.5])  # Fechado

        print("ğŸ‘‰ Apontando")

    def thumbs_up(self):
        """Gesto: joinha"""
        self._set_finger("thumb", [0.5, 0.0, 0.0, 0.0])  # Polegar para cima
        self._set_finger("index", [1.5, 1.8, 1.5])  # Fechado
        self._set_finger("middle", [1.5, 1.8, 1.5])

        print("ğŸ‘ Thumbs up!")

    def _set_finger(self, finger_name: str, angles: list):
        """Define Ã¢ngulos de um dedo"""
        joints = self.finger_joints[finger_name]

        for joint, angle in zip(joints, angles):
            cmd = JointCommand()
            cmd.joint_name = joint
            cmd.control_mode = "POSITION"
            cmd.target_position = angle
            cmd.max_velocity = 2.0
            cmd.kp = 50.0
            cmd.kd = 2.0

            self.robot.send_command(cmd)

# Uso:
def demo_dexterous_hand():
    robot = G1Robot()
    robot.wait_for_connection()

    hand = DexterousHandController(robot, arm="right")

    # SequÃªncia de gestos
    hand.thumbs_up()
    time.sleep(2)

    hand.point()
    time.sleep(2)

    hand.precision_grasp(object_diameter=0.025)
    time.sleep(2)

    hand.power_grasp()

    robot.disconnect()
```

---

## ğŸ“¦ Pick and Place

```python
#!/usr/bin/env python3
"""
pick_and_place.py - Sistema completo de manipulaÃ§Ã£o
"""

from enum import Enum

class PickPlaceState(Enum):
    IDLE = "idle"
    APPROACHING = "approaching"
    GRASPING = "grasping"
    LIFTING = "lifting"
    MOVING = "moving"
    PLACING = "placing"
    RELEASING = "releasing"

class PickPlaceController:
    def __init__(self, robot: G1Robot, arm="left"):
        self.robot = robot
        self.arm = arm

        # Sub-controllers
        self.ik = G1ArmIK(arm)
        self.gripper = GripperController(robot, arm)

        # Estado
        self.state = PickPlaceState.IDLE

    def pick_and_place(self, pick_pos: np.ndarray, place_pos: np.ndarray,
                        object_width: float = 0.05):
        """
        Executa pick and place completo

        Args:
            pick_pos: [x, y, z] posiÃ§Ã£o do objeto
            place_pos: [x, y, z] onde colocar
            object_width: Largura do objeto [m]
        """
        print(f"ğŸ¯ Pick and Place: {pick_pos} â†’ {place_pos}")

        # 1. Abrir gripper
        self.state = PickPlaceState.IDLE
        self.gripper.open()
        time.sleep(1)

        # 2. Aproximar (acima do objeto)
        self.state = PickPlaceState.APPROACHING
        approach_pos = pick_pos + np.array([0, 0, 0.15])  # 15cm acima
        if not self.ik.move_to_position(self.robot, approach_pos, duration=2.0):
            print("âŒ Falha ao aproximar")
            return False

        # 3. Descer
        if not self.ik.move_to_position(self.robot, pick_pos, duration=1.5):
            print("âŒ Falha ao descer")
            return False

        # 4. Pegar
        self.state = PickPlaceState.GRASPING
        self.gripper.grasp(object_width, force=15.0)
        time.sleep(1)

        # 5. Levantar
        self.state = PickPlaceState.LIFTING
        lift_pos = pick_pos + np.array([0, 0, 0.20])
        self.ik.move_to_position(self.robot, lift_pos, duration=1.5)

        # 6. Mover para lugar
        self.state = PickPlaceState.MOVING
        place_approach = place_pos + np.array([0, 0, 0.15])
        self.ik.move_to_position(self.robot, place_approach, duration=3.0)

        # 7. Descer
        self.state = PickPlaceState.PLACING
        self.ik.move_to_position(self.robot, place_pos, duration=1.5)

        # 8. Soltar
        self.state = PickPlaceState.RELEASING
        self.gripper.open()
        time.sleep(1)

        # 9. Retrair
        self.ik.move_to_position(self.robot, place_approach, duration=1.5)

        self.state = PickPlaceState.IDLE
        print("âœ… Pick and Place concluÃ­do!")
        return True

# Uso:
def main():
    robot = G1Robot()
    robot.wait_for_connection()

    pp_ctrl = PickPlaceController(robot, arm="right")

    # Pegar objeto em (0.4, -0.2, 0.1) e colocar em (0.4, 0.2, 0.2)
    pick_position = np.array([0.4, -0.2, 0.1])
    place_position = np.array([0.4, 0.2, 0.2])

    pp_ctrl.pick_and_place(pick_position, place_position, object_width=0.06)

    robot.disconnect()

if __name__ == "__main__":
    main()
```

---

## ğŸ’ª Force Control

```python
class ForceController:
    def __init__(self, robot: G1Robot, arm="left"):
        self.robot = robot
        self.arm = arm

        # ParÃ¢metros de impedÃ¢ncia
        self.K = np.diag([100, 100, 100])  # Rigidez [N/m]
        self.D = np.diag([10, 10, 10])     # Damping [N/(m/s)]

    def admittance_control(self, target_force: np.ndarray, duration=5.0):
        """
        Controle de admitÃ¢ncia (robÃ´ "macio")

        Args:
            target_force: [Fx, Fy, Fz] forÃ§a desejada [N]
            duration: Tempo de controle [s]
        """
        start_time = time.time()

        while (time.time() - start_time) < duration:
            # Medir forÃ§a atual (via torque das juntas)
            state = self.robot.get_state()
            current_force = self._estimate_end_effector_force(state)

            # Erro de forÃ§a
            force_error = target_force - current_force

            # Deslocamento desejado (admitÃ¢ncia)
            # Î”x = (F_error) / K
            position_delta = np.linalg.inv(self.K) @ force_error

            # Atualizar posiÃ§Ã£o alvo
            # (requer FK/IK em loop)

            time.sleep(0.01)  # 100 Hz

    def _estimate_end_effector_force(self, state) -> np.ndarray:
        """Estima forÃ§a no end-effector via Jacobian transpose"""
        # SimplificaÃ§Ã£o: retornar zeros
        # Em produÃ§Ã£o: F = J^T * Ï„
        return np.zeros(3)
```

---

## âœ… Checklist de ConclusÃ£o

- [ ] Implementei Forward Kinematics (DH parameters)
- [ ] Implementei Inverse Kinematics (analytical 3D)
- [ ] Controlei gripper (abrir/fechar/forÃ§a)
- [ ] Testei dexterous hand (gestos, precision/power grasp)
- [ ] Implementei Pick and Place completo
- [ ] Entendi Force Control (admittance)

---

## ğŸ”— PrÃ³ximos Passos

:::tip PrÃ³ximo MÃ³dulo
**[ğŸ¤ IntegraÃ§Ã£o ROS2 com G1 â†’](./integracao-ros2-g1)**

Crie bridge ROS2, tf2 transforms, MoveIt config e Nav2 config para o G1.
:::

---

**â±ï¸ Tempo estimado:** 80-100 min
**ğŸ§  NÃ­vel:** AvanÃ§ado
**ğŸ’» Hands-on:** 75% prÃ¡tico, 25% teÃ³rico
