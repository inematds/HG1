---
sidebar_position: 5
title: 5. Calibra√ß√£o de Sistemas
description: Calibra√ß√£o de IMU, encoders, sensores de for√ßa e c√¢meras
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# ‚öôÔ∏è Calibra√ß√£o de Sistemas

:::tip Objetivo do M√≥dulo
Aprender a calibrar os principais sensores de um humanoide para garantir precis√£o m√°xima em opera√ß√£o.
:::

---

## üß≠ Calibra√ß√£o de IMU (Unidade de Medi√ß√£o Inercial)

### Por Que Calibrar?

IMU mede **acelera√ß√£o** e **rota√ß√£o**, mas sofre de **drift** (desvio acumulado). Sem calibra√ß√£o, ap√≥s 10 minutos o rob√¥ pode pensar que est√° inclinado 5¬∞.

### Procedimento de Calibra√ß√£o

<Tabs>
<TabItem value="static" label="üõë Calibra√ß√£o Est√°tica">

**Quando:** Calibrar offsets de aceler√¥metro e girosc√≥pio

**Passos:**

```bash
# 1. Colocar rob√¥ em superf√≠cie PERFEITAMENTE plana
# 2. Rob√¥ totalmente parado (motores desligados)
# 3. Executar calibra√ß√£o

ros2 run robot_calibration calibrate_imu

# Aguardar 60 segundos (coleta 6000 amostras @ 100 Hz)
# Sa√≠da:
# Accel offset: x=0.02, y=-0.01, z=9.81
# Gyro offset: x=0.001, y=0.002, z=0.000
```

**Salvar Calibra√ß√£o:**

```yaml
# imu_calibration.yaml
accelerometer_offset:
  x: 0.02
  y: -0.01
  z: 0.00  # Z deve ser ~0 (9.81 √© gravidade)
gyroscope_offset:
  x: 0.001
  y: 0.002
  z: 0.000
```

</TabItem>
<TabItem value="dynamic" label="üîÑ Calibra√ß√£o Din√¢mica">

**Quando:** Calibrar matriz de transforma√ß√£o

**Procedimento:**

1. **Rota√ß√£o em X** (pitch): Inclinar rob√¥ para frente/tr√°s
2. **Rota√ß√£o em Y** (roll): Inclinar rob√¥ esquerda/direita
3. **Rota√ß√£o em Z** (yaw): Girar rob√¥ 360¬∞

```python
import numpy as np

# Dados coletados durante rota√ß√µes
accel_samples = []  # Lista de (ax, ay, az)
gyro_samples = []   # Lista de (gx, gy, gz)

# Calcular matriz de calibra√ß√£o
accel_mean = np.mean(accel_samples, axis=0)
accel_std = np.std(accel_samples, axis=0)

# Fator de escala (ideal = 1.0)
scale_factor = 9.81 / np.linalg.norm(accel_mean)

print(f"Scale factor: {scale_factor}")  # Deve estar entre 0.95-1.05
```

</TabItem>
</Tabs>

### Verifica√ß√£o P√≥s-Calibra√ß√£o

```bash
# Verificar se IMU est√° reportando corretamente
ros2 topic echo /imu/data

# Com rob√¥ parado e plano:
# - angular_velocity: ~(0, 0, 0)
# - linear_acceleration.z: ~9.81 m/s¬≤
```

---

## üîß Calibra√ß√£o de Encoders

### O Que S√£o Encoders?

Sensores que medem **√¢ngulo das juntas** (quantos graus o joelho flexionou).

### Calibrar Zero Mec√¢nico

<Tabs>
<TabItem value="manual" label="üñêÔ∏è Calibra√ß√£o Manual">

**Procedimento:**

1. **Posicionar junta em posi√ß√£o conhecida** (ex: joelho totalmente reto = 0¬∞)
2. **Executar comando de calibra√ß√£o:**

```python
import rclpy
from std_srvs.srv import Trigger

# Chamar servi√ßo de calibra√ß√£o
client = node.create_client(Trigger, '/calibrate_joint_left_knee')
client.wait_for_service()

request = Trigger.Request()
response = client.call(request)

if response.success:
    print("Calibrado: left_knee @ 0¬∞")
```

</TabItem>
<TabItem value="auto" label="ü§ñ Calibra√ß√£o Autom√°tica">

**Usando Limites Mec√¢nicos:**

Alguns rob√¥s t√™m **limit switches** (chaves fim-de-curso). O rob√¥ move a junta at√© tocar o limite, ent√£o sabe que est√° em 0¬∞.

```python
def auto_calibrate_joint(joint_name):
    # 1. Mover lentamente at√© limit switch
    while not limit_switch_pressed(joint_name):
        move_joint(joint_name, velocity=-0.1)  # Velocidade baixa

    # 2. Zerar encoder
    reset_encoder(joint_name)
    print(f"{joint_name} calibrated to 0¬∞")
```

</TabItem>
</Tabs>

---

## ‚öñÔ∏è Calibra√ß√£o de Sensores de For√ßa/Torque

### Onde Est√£o?

- **P√©s** (medir for√ßa de contato com ch√£o)
- **Punhos** (medir for√ßa ao pegar objetos)

### Calibra√ß√£o de Offset

```python
# Rob√¥ suspenso (p√©s no ar, sem carga)
force_samples = []
for i in range(100):
    force = read_force_sensor('left_foot')
    force_samples.append(force)

offset = np.mean(force_samples, axis=0)
# offset = (0.5, -0.2, 2.0) N

# Salvar
save_calibration('left_foot', offset)
```

### Calibra√ß√£o de Escala

```python
# Aplicar peso conhecido (ex: 10 kg = 98.1 N)
force_with_weight = read_force_sensor('left_foot') - offset
expected_force = 98.1  # N

scale_factor = expected_force / force_with_weight[2]  # Eixo Z
print(f"Scale: {scale_factor}")  # Deve ser ~1.0
```

---

## üì∑ Calibra√ß√£o de C√¢meras

### Par√¢metros Intr√≠nsecos

**O que calibrar:** Distor√ß√£o da lente, focal length

**Ferramenta:** OpenCV

```bash
# Imprimir padr√£o xadrez
# https://docs.opencv.org/4.x/pattern.png

# Capturar 20+ fotos do padr√£o em √¢ngulos diferentes
ros2 run image_view image_saver --ros-args -r image:=/camera/image_raw

# Calibrar
ros2 run camera_calibration cameracalibrator --size 8x6 --square 0.025 image:=/camera/image_raw
```

**Sa√≠da:**

```yaml
image_width: 1280
image_height: 720
camera_matrix:
  rows: 3
  cols: 3
  data: [800.0, 0.0, 640.0,
         0.0, 800.0, 360.0,
         0.0, 0.0, 1.0]
distortion_coefficients:
  rows: 1
  cols: 5
  data: [-0.2, 0.05, 0.0, 0.0, 0.0]  # k1, k2, p1, p2, k3
```

### Par√¢metros Extr√≠nsecos

**O que calibrar:** Posi√ß√£o da c√¢mera relativa ao corpo do rob√¥

**Ferramenta:** TF tree + ArUco marker

```python
# Rob√¥ olha para marcador ArUco de posi√ß√£o conhecida
# Sistema calcula transforma√ß√£o camera ‚Üí base_link
```

---

## üéØ Checklist de Calibra√ß√£o Completo

```markdown
PR√â-OPERA√á√ÉO DI√ÅRIA:
‚ñ° IMU: Verificar drift (&lt; 0.5¬∞/min)
‚ñ° Encoders: Testar 5 juntas aleat√≥rias
‚ñ° For√ßa: Zero com rob√¥ suspenso

SEMANAL:
‚ñ° C√¢meras: Verificar foco e distor√ß√£o
‚ñ° IMU: Calibra√ß√£o est√°tica completa

MENSAL:
‚ñ° Encoders: Calibra√ß√£o completa de todos
‚ñ° For√ßa: Teste com pesos conhecidos
‚ñ° C√¢meras: Recalibra√ß√£o intrinseca
```

---

## üîó Pr√≥ximos Passos

:::tip Pr√≥ximo M√≥dulo
**[üîß Manuten√ß√£o Preventiva ‚Üí](./manutencao)**

Aprenda inspe√ß√£o, lubrifica√ß√£o e troca de componentes.
:::
